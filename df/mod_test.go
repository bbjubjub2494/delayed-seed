package df

import (
	"math/big"
	"testing"
)

func testParams(t testing.TB) *RsaGroupWithTrapdoor {
	mod, ok := new(big.Int).SetString("773471670135400506697123136612313394917706398418689601987505980413601849953694612413708789847602725417567280026779946802831293657930707208029052188703718288078686616385905469642118137839205940287539793217050419853372065587054840374517203054223088666294096631447692504575094983589589490070034510015616088837585901687068634328707168880572265358946696726952385572479061484834879659689761556081378855981974774533257538031003977996703036822877309000411479282020762586199074673219120004474498012226412889401416236809041340907231650550598205809191893710240303210493466095356312140824538794642228146047914646170192303147555988205694635253908876747687907789184207228982246696030657625071806185361584516541398565247295938521489410310094105427442650053146493922295529462074528320529156264851146001041240296319553597361491742223676850036887177414946155996502066203596259428687511843009756369299325378361513819312823251479231873598641720971801587980537820253823837610618729184504050844526675002163387184381233327760323621824206312025763174934921399837439801211922046655038731179999075685351751353010025741189810531385331260967589671912965429772118235627701004149716690768058775461992475368416636382648652301297911123692557843786843627851089799199", 10)
	if !ok {
		t.Fatalf("could not parse mod")
	}
	order, ok := new(big.Int).SetString("773471670135400506697123136612313394917706398418689601987505980413601849953694612413708789847602725417567280026779946802831293657930707208029052188703718288078686616385905469642118137839205940287539793217050419853372065587054840374517203054223088666294096631447692504575094983589589490070034510015616088837585901687068634328707168880572265358946696726952385572479061484834879659689761556081378855981974774533257538031003977996703036822877309000411479282020762586199074673219120004474498012226412889401416236809041340907231650550598205809191893710240303210493466095356312140824538794642228146047914646170192303147555932578370140314733506711896204355833388062698636897824772781112075601762794826923135801530606225715873679000054572174192198342894465513090265959409139352182432641137279880090153748674960924933868672952239138407297732131536253681953454137740504495378838927724493481949577912568189772285712631169488997992673713412775062303824165823280463226049826332954006847422843821591756880897991029547794778237660538170988075693839240511482451798611051170371943074064935871256375575540631135807314367486695004409036987981246216122384613318220208371677269534055398971303919394475283171666130765314972401512859173289301789998058652536", 10)
	if !ok {
		t.Fatalf("could not parse order")
	}
	return &RsaGroupWithTrapdoor{RsaGroup{mod}, order}
}

func FuzzEvalConsistent(f *testing.F) {
	params := testParams(f)

	f.Add([]byte{2}, uint64(100000))
	f.Fuzz(func(t *testing.T, xBytes []byte, iterations uint64) {
		x := new(big.Int).SetBytes(xBytes)
		y := (*big.Int)(params.FastEval(x, iterations))
		z := params.Eval(x, iterations)
		t.Logf("x =          %v", x)
		t.Logf("iterations = %v", iterations)
		t.Logf("y =          %v", y)
		t.Logf("z =          %v", z)
		if y.Cmp(z) != 0 {
			t.Fatalf("y != z")
		}
	})
}

func BenchmarkSlowPow(b *testing.B) {
	params := testParams(b)

	iterations := uint64(100000)
	b.Logf("iterations = %v", iterations)
	x := params.HashToGroup([]byte("test"))
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = params.Eval(x, iterations)
	}
}
